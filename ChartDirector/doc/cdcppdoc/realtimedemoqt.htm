<HTML>
<HEAD>
<Title>Simple Realtime Chart (QT)</Title>
<link type='text/css' rel='Stylesheet' href="maxchartapi.css" />
</HEAD>
<body bgcolor="#FFFFFF" text="#000000" topmargin="0" leftmargin="0" rightmargin="0" marginwidth="0" marginheight="0">
<p class="heading0">ChartDirector 6.0 (C++ Edition)</p>
<p class="heading1">Simple Realtime Chart (QT)</p>
<hr class="separator">
<div class="content"><img src="images/realtimedemo_qt.png"><br><br>
<div style="background-color:#cccccc;width:99%;padding:10px">
<b><font color="#FF0000">NOTE:</font></b> This section describes Simple Realtime Chart for QT only. For MFC, please refer to <a href="realtimedemo.htm">Simple Realtime Chart (MFC)</a>.
</div><br>
This sample program demonstrates a realtime chart with configurable chart update rate.<br><br>
In this sample program, new values are generated by a random number generator driven by a timer. The values are "shifted" into data arrays, which are used for creating the chart.<br><br>
The chart is updated by a second timer. This allows the chart update rate to be configurable independently from the data rate. Also, the chart can be "frozen" for easy reading, while the data can continue to update on the background.<br><br>
To demonstrate the code structure for update rate control (even though for the update rate in this demo it is not necessary to have any rate control), instead of directly updating the chart, the chart update timer calls <a href="QChartViewer.updateViewPort.htm">QChartViewer.updateViewPort</a> to trigger the     <a href="QChartViewer.viewPortChanged.htm">QChartViewer.viewPortChanged</a> signal      , and the chart is updated in its handler.
</div><p class="heading1a">Source Code Listing</p><div class="content">
The following is the main source code of this demo. The complete QT  project is in "qtdemo/realtimedemo".<br><br>
[File: qtdemo/realtimedemo/realtimedemo.cpp]<table width="98%" border="0" cellpadding="10"><tr><td bgcolor="#cccccc"><pre>#include &lt;QApplication&gt;
#include &lt;QButtonGroup&gt;
#include &lt;QIcon&gt;
#include &lt;QPushButton&gt;
#include &lt;QComboBox&gt;
#include "realtimedemo.h"
#include "chartdir.h"
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;


int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    app.setStyleSheet("* {font-family:arial;font-size:11px}");
    RealtimeDemo demo;
    demo.show();
    return app.exec();
}


static const int DataInterval = 250;

RealtimeDemo::RealtimeDemo(QWidget *parent) :
    QDialog(parent)
{
    //
    // Set up the GUI
    //

    setFixedSize(740, 285);
    setWindowTitle("Simple Realtime Chart");

    // The frame on the left side
    QFrame *frame = new QFrame(this);
    frame-&gt;setGeometry(4, 4, 120, 277);
    frame-&gt;setFrameShape(QFrame::StyledPanel);

    // Run push button
    QPushButton *runPB = new QPushButton(QIcon(":/play.png"), "Run", frame);
    runPB-&gt;setGeometry(4, 8, 112, 28);
    runPB-&gt;setStyleSheet("QPushButton { text-align:left; padding:5px}");
    runPB-&gt;setCheckable(true);

    // Freeze push button
    QPushButton *freezePB = new QPushButton(QIcon(":/pause.png"), "Freeze", frame);
    freezePB-&gt;setGeometry(4, 36, 112, 28);
    freezePB-&gt;setStyleSheet("QPushButton { text-align:left; padding:5px}");
    freezePB-&gt;setCheckable(true);

    // The Run/Freeze buttons form a button group
    QButtonGroup *runFreezeControl = new QButtonGroup(frame);
    runFreezeControl-&gt;addButton(runPB, 1);
    runFreezeControl-&gt;addButton(freezePB, 0);
    connect(runFreezeControl, SIGNAL(buttonPressed(int)), SLOT(onRunFreezeChanged(int)));

    // Update Period drop down list box
    (new QLabel("Update Period (ms)", frame))-&gt;setGeometry(6, 80, 108, 16);
    QComboBox *updatePeriod = new QComboBox(frame);
    updatePeriod-&gt;setGeometry(6, 96, 108, 21);
    updatePeriod-&gt;addItems(QStringList() &lt;&lt; "250" &lt;&lt; "500" &lt;&lt; "750" &lt;&lt; "1000" &lt;&lt; "1250" &lt;&lt; "1500"
                           &lt;&lt; "1750" &lt;&lt; "2000");
    connect(updatePeriod, SIGNAL(currentIndexChanged(QString)),
            SLOT(onUpdatePeriodChanged(QString)));

    // Alpha Value display
    (new QLabel("Alpha", frame))-&gt;setGeometry(6, 200, 48, 21);
    m_ValueA = new QLabel(frame);
    m_ValueA-&gt;setGeometry(55, 200, 59, 21);
    m_ValueA-&gt;setFrameShape(QFrame::StyledPanel);

    // Beta Value display
    (new QLabel("Beta", frame))-&gt;setGeometry(6, 223, 48, 21);
    m_ValueB = new QLabel(frame);
    m_ValueB-&gt;setGeometry(55, 223, 59, 21);
    m_ValueB-&gt;setFrameShape(QFrame::StyledPanel);

    // Gamma Value display
    (new QLabel("Gamma", frame))-&gt;setGeometry(6, 246, 48, 21);
    m_ValueC = new QLabel(frame);
    m_ValueC-&gt;setGeometry(55, 246, 59, 21);
    m_ValueC-&gt;setFrameShape(QFrame::StyledPanel);

    // Chart Viewer
    m_ChartViewer = new QChartViewer(this);
    m_ChartViewer-&gt;setGeometry(132, 8, 600, 270);
    connect(m_ChartViewer, SIGNAL(viewPortChanged()), SLOT(drawChart()));

    // Clear data arrays to Chart::NoValue
    for (int i = 0; i &lt; sampleSize; ++i)
        m_timeStamps[i] = m_dataSeriesA[i] = m_dataSeriesB[i] = m_dataSeriesC[i] = Chart::NoValue;

    // Set m_nextDataTime to the current time. It is used by the real time random number
    // generator so it knows what timestamp should be used for the next data point.
    m_nextDataTime = QDateTime::currentDateTime();

    // Set up the data acquisition mechanism. In this demo, we just use a timer to get a
    // sample every 250ms.
    QTimer *dataRateTimer = new QTimer(this);
    dataRateTimer-&gt;start(DataInterval);
    connect(dataRateTimer, SIGNAL(timeout()), SLOT(getData()));

    // Set up the chart update timer
    m_ChartUpdateTimer = new QTimer(this);
    connect(m_ChartUpdateTimer, SIGNAL(timeout()), SLOT(updateChart()));

    // Can start now
    updatePeriod-&gt;setCurrentIndex(3);
    runPB-&gt;click();
}

//
// A utility to shift a new data value into a data array
//
static void shiftData(double *data, int len, double newValue)
{
    memmove(data, data + 1, sizeof(*data) * (len - 1));
    data[len - 1] = newValue;
}

//
// Shift new data values into the real time data series
//
void RealtimeDemo::getData()
{
    // The current time
    QDateTime now = QDateTime::currentDateTime();

    // This is our formula for the random number generator
    do
    {
        // We need the currentTime in millisecond resolution
        double currentTime = Chart::chartTime2(m_nextDataTime.toTime_t())
                             + m_nextDataTime.time().msec() / 1000.0;

        // Get a data sample
        double p = currentTime * 4;
        double dataA = 20 + cos(p * 129241) * 10 + 1 / (cos(p) * cos(p) + 0.01);
        double dataB = 150 + 100 * sin(p / 27.7) * sin(p / 10.1);
        double dataC = 150 + 100 * cos(p / 6.7) * cos(p / 11.9);

        // Shift the values into the arrays
        shiftData(m_dataSeriesA, sampleSize, dataA);
        shiftData(m_dataSeriesB, sampleSize, dataB);
        shiftData(m_dataSeriesC, sampleSize, dataC);
        shiftData(m_timeStamps, sampleSize, currentTime);

        m_nextDataTime = m_nextDataTime.addMSecs(DataInterval);
    }
    while (m_nextDataTime &lt; now);

    //
    // We provide some visual feedback to the latest numbers generated, so you can see the
    // data being generated.
    //
    m_ValueA-&gt;setText(QString::number(m_dataSeriesA[sampleSize - 1], 'f', 2));
    m_ValueB-&gt;setText(QString::number(m_dataSeriesB[sampleSize - 1], 'f', 2));
    m_ValueC-&gt;setText(QString::number(m_dataSeriesC[sampleSize - 1], 'f', 2));
}

//
// The Run or Freeze button is pressed
//
void RealtimeDemo::onRunFreezeChanged(int run)
{
    if (run)
        m_ChartUpdateTimer-&gt;start();
    else
        m_ChartUpdateTimer-&gt;stop();
}

//
// User changes the chart update period
//
void RealtimeDemo::onUpdatePeriodChanged(QString text)
{
    m_ChartUpdateTimer-&gt;start(text.toInt());
}

//
// Update the chart. Instead of drawing the chart directly, we call updateViewPort, which
// will trigger a ViewPortChanged signal. We update the chart in the signal handler
// "drawChart". This can take advantage of the built-in rate control in QChartViewer to
// ensure a smooth user interface, even for extremely high update rate. (See the
// documentation on QChartViewer.setUpdateInterval).
//
void RealtimeDemo::updateChart()
{
    m_ChartViewer-&gt;updateViewPort(true, false);
}

//
// Draw chart
//
void RealtimeDemo::drawChart()
{
    // Create an XYChart object 600 x 270 pixels in size, with light grey (f4f4f4)
    // background, black (000000) border, 1 pixel raised effect, and with a rounded frame.
    XYChart *c = new XYChart(600, 270, 0xf4f4f4, 0x000000, 1);
    QColor bgColor = palette().color(backgroundRole()).rgb();
    c-&gt;setRoundedFrame((bgColor.red() &lt;&lt; 16) + (bgColor.green() &lt;&lt; 8) + bgColor.blue());

    // Set the plotarea at (55, 62) and of size 520 x 175 pixels. Use white (ffffff)
    // background. Enable both horizontal and vertical grids by setting their colors to
    // grey (cccccc). Set clipping mode to clip the data lines to the plot area.
    c-&gt;setPlotArea(55, 62, 520, 175, 0xffffff, -1, -1, 0xcccccc, 0xcccccc);
    c-&gt;setClipping();

    // Add a title to the chart using 15 pts Times New Roman Bold Italic font, with a light
    // grey (dddddd) background, black (000000) border, and a glass like raised effect.
    c-&gt;addTitle("Field Intensity at Observation Satellite", "timesbi.ttf", 15
        )-&gt;setBackground(0xdddddd, 0x000000, Chart::glassEffect());

    // Add a legend box at the top of the plot area with 9pts Arial Bold font. We set the
    // legend box to the same width as the plot area and use grid layout (as opposed to
    // flow or top/down layout). This distributes the 3 legend icons evenly on top of the
    // plot area.
    LegendBox *b = c-&gt;addLegend2(55, 33, 3, "arialbd.ttf", 9);
    b-&gt;setBackground(Chart::Transparent, Chart::Transparent);
    b-&gt;setWidth(520);

    // Configure the y-axis with a 10pts Arial Bold axis title
    c-&gt;yAxis()-&gt;setTitle("Intensity (V/m)", "arialbd.ttf", 10);

    // Configure the x-axis to auto-scale with at least 75 pixels between major tick and
    // 15  pixels between minor ticks. This shows more minor grid lines on the chart.
    c-&gt;xAxis()-&gt;setTickDensity(75, 15);

    // Set the axes width to 2 pixels
    c-&gt;xAxis()-&gt;setWidth(2);
    c-&gt;yAxis()-&gt;setWidth(2);

    // Now we add the data to the chart.
    double lastTime = m_timeStamps[sampleSize - 1];
    if (lastTime != Chart::NoValue)
    {
        // Set up the x-axis to show the time range in the data buffer
        c-&gt;xAxis()-&gt;setDateScale(lastTime - DataInterval * sampleSize / 1000, lastTime);

        // Set the x-axis label format
        c-&gt;xAxis()-&gt;setLabelFormat("{value|hh:nn:ss}");

        // Create a line layer to plot the lines
        LineLayer *layer = c-&gt;addLineLayer();

        // The x-coordinates are the timeStamps.
        layer-&gt;setXData(DoubleArray(m_timeStamps, sampleSize));

        // The 3 data series are used to draw 3 lines. Here we put the latest data values
        // as part of the data set name, so you can see them updated in the legend box.
        char buffer[1024];

        sprintf(buffer, "Software: &lt;*bgColor=FFCCCC*&gt; %.2f ", m_dataSeriesA[sampleSize - 1]);
        layer-&gt;addDataSet(DoubleArray(m_dataSeriesA, sampleSize), 0xff0000, buffer);

        sprintf(buffer, "Hardware: &lt;*bgColor=CCFFCC*&gt; %.2f ", m_dataSeriesB[sampleSize - 1]);
        layer-&gt;addDataSet(DoubleArray(m_dataSeriesB, sampleSize), 0x00cc00, buffer);

        sprintf(buffer, "Services: &lt;*bgColor=CCCCFF*&gt; %.2f ", m_dataSeriesC[sampleSize - 1]);
        layer-&gt;addDataSet(DoubleArray(m_dataSeriesC, sampleSize), 0x0000ff, buffer);
    }

    // Set the chart image to the WinChartViewer
    m_ChartViewer-&gt;setChart(c);
    delete c;
}</pre></td></tr></table></div><br>
<hr class="separator"><div class="copyright">&copy; 2015 Advanced Software Engineering Limited. All rights reserved.</div></body>
</HTML>
