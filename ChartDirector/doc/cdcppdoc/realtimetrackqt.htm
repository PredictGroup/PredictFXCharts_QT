<HTML>
<HEAD>
<Title>Realtime Chart with Track Line (QT)</Title>
<link type='text/css' rel='Stylesheet' href="maxchartapi.css" />
</HEAD>
<body bgcolor="#FFFFFF" text="#000000" topmargin="0" leftmargin="0" rightmargin="0" marginwidth="0" marginheight="0">
<p class="heading0">ChartDirector 6.0 (C++ Edition)</p>
<p class="heading1">Realtime Chart with Track Line (QT)</p>
<hr class="separator">
<div class="content"><img src="images/realtimetrack_qt.png"><br><br>
<div style="background-color:#cccccc;width:99%;padding:10px">
<b><font color="#FF0000">NOTE:</font></b> This section describes Realtime Chart with Track Line for QT only. For MFC, please refer to <a href="realtimetrack.htm">Realtime Chart with Track Line (MFC)</a>.
</div><br>
This sample program demonstrates a realtime chart with configurable chart update rate. It includes a track cursor that updates the legend to display the data values as the mouse cursor moves over the chart. When the mouse is not over the chart, the track cursor will display the latest data values in the legend.<br><br>
In this sample program, new values are generated by a random number generator driven by a timer. The values are initially appended to data arrays which are used for creating the chart. When the number of values exceeds the array size, new values will be "shifted" into the array.<br><br>
The chart is updated by a second timer. This allows the chart update rate to be configurable independent of the data rate. Also, the chart can be "frozen" for easy reading, while the data can continue to update on the background.<br><br>
To demonstrate the code structure for update rate control (even though for the update rate in this demo it is not necessary to have any rate control), instead of directly updating the chart, the chart update timer calls <a href="QChartViewer.updateViewPort.htm">QChartViewer.updateViewPort</a> to trigger the     <a href="QChartViewer.viewPortChanged.htm">QChartViewer.viewPortChanged</a> signal      , and the chart is updated in its handler.<br><br>
The track cursor drawing code is essentially the same as that in <a href="tracklegend.htm">Track Line with Legend (MFC)</a>. Please refer to that example for the explanation of the code.
</div><p class="heading1a">Source Code Listing</p><div class="content">
The following is the main source code of this demo. The complete QT  project is in "qtdemo/realtimetrack".<br><br>
[File: qtdemo/realtimetrack/realtimetrack.cpp]<table width="98%" border="0" cellpadding="10"><tr><td bgcolor="#cccccc"><pre>#include &lt;QApplication&gt;
#include &lt;QButtonGroup&gt;
#include &lt;QIcon&gt;
#include &lt;QPushButton&gt;
#include &lt;QComboBox&gt;
#include "realtimetrack.h"
#include "chartdir.h"
#include &lt;math.h&gt;
#include &lt;vector&gt;
#include &lt;sstream&gt;

using namespace std;


int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    app.setStyleSheet("* {font-family:arial;font-size:11px}");
    RealtimeTrack demo;
    demo.show();
    return app.exec();
}


static const int DataInterval = 250;

RealtimeTrack::RealtimeTrack(QWidget *parent) :
    QDialog(parent)
{
    //
    // Set up the GUI
    //

    setFixedSize(740, 285);
    setWindowTitle("Realtime Chart with Track Line");

    // The frame on the left side
    QFrame *frame = new QFrame(this);
    frame-&gt;setGeometry(4, 4, 120, 277);
    frame-&gt;setFrameShape(QFrame::StyledPanel);

    // Run push button
    QPushButton *runPB = new QPushButton(QIcon(":/play.png"), "Run", frame);
    runPB-&gt;setGeometry(4, 8, 112, 28);
    runPB-&gt;setStyleSheet("QPushButton { text-align:left; padding:5px}");
    runPB-&gt;setCheckable(true);

    // Freeze push button
    QPushButton *freezePB = new QPushButton(QIcon(":/pause.png"), "Freeze", frame);
    freezePB-&gt;setGeometry(4, 36, 112, 28);
    freezePB-&gt;setStyleSheet("QPushButton { text-align:left; padding:5px}");
    freezePB-&gt;setCheckable(true);

    // The Run/Freeze buttons form a button group
    QButtonGroup *runFreezeControl = new QButtonGroup(frame);
    runFreezeControl-&gt;addButton(runPB, 1);
    runFreezeControl-&gt;addButton(freezePB, 0);
    connect(runFreezeControl, SIGNAL(buttonPressed(int)), SLOT(onRunFreezeChanged(int)));

    // Update Period drop down list box
    (new QLabel("Update Period (ms)", frame))-&gt;setGeometry(6, 80, 108, 16);
    QComboBox *updatePeriod = new QComboBox(frame);
    updatePeriod-&gt;setGeometry(6, 96, 108, 21);
    updatePeriod-&gt;addItems(QStringList() &lt;&lt; "250" &lt;&lt; "500" &lt;&lt; "750" &lt;&lt; "1000" &lt;&lt; "1250" &lt;&lt; "1500"
                           &lt;&lt; "1750" &lt;&lt; "2000");
    connect(updatePeriod, SIGNAL(currentIndexChanged(QString)),
            SLOT(onUpdatePeriodChanged(QString)));

    // Alpha Value display
    (new QLabel("Alpha", frame))-&gt;setGeometry(6, 200, 48, 21);
    m_ValueA = new QLabel(frame);
    m_ValueA-&gt;setGeometry(55, 200, 59, 21);
    m_ValueA-&gt;setFrameShape(QFrame::StyledPanel);

    // Beta Value display
    (new QLabel("Beta", frame))-&gt;setGeometry(6, 223, 48, 21);
    m_ValueB = new QLabel(frame);
    m_ValueB-&gt;setGeometry(55, 223, 59, 21);
    m_ValueB-&gt;setFrameShape(QFrame::StyledPanel);

    // Gamma Value display
    (new QLabel("Gamma", frame))-&gt;setGeometry(6, 246, 48, 21);
    m_ValueC = new QLabel(frame);
    m_ValueC-&gt;setGeometry(55, 246, 59, 21);
    m_ValueC-&gt;setFrameShape(QFrame::StyledPanel);

    // Chart Viewer
    m_ChartViewer = new QChartViewer(this);
    m_ChartViewer-&gt;setGeometry(132, 8, 600, 270);
    connect(m_ChartViewer, SIGNAL(viewPortChanged()), SLOT(drawChart()));
    connect(m_ChartViewer, SIGNAL(mouseMovePlotArea(QMouseEvent*)),
        SLOT(onMouseMovePlotArea(QMouseEvent*)));

    // Clear data arrays to Chart::NoValue
    for (int i = 0; i &lt; sampleSize; ++i)
        m_timeStamps[i] = m_dataSeriesA[i] = m_dataSeriesB[i] = m_dataSeriesC[i] = Chart::NoValue;
    m_currentIndex = 0;

    // Set m_nextDataTime to the current time. It is used by the real time random number
    // generator so it knows what timestamp should be used for the next data point.
    m_nextDataTime = QDateTime::currentDateTime();

    // Set up the data acquisition mechanism. In this demo, we just use a timer to get a
    // sample every 250ms.
    QTimer *dataRateTimer = new QTimer(this);
    dataRateTimer-&gt;start(DataInterval);
    connect(dataRateTimer, SIGNAL(timeout()), SLOT(getData()));

    // Set up the chart update timer
    m_ChartUpdateTimer = new QTimer(this);
    connect(m_ChartUpdateTimer, SIGNAL(timeout()), SLOT(updateChart()));

    // Can start now
    updatePeriod-&gt;setCurrentIndex(3);
    runPB-&gt;click();
}

RealtimeTrack::~RealtimeTrack()
{
    delete m_ChartViewer-&gt;getChart();   
}
        
//
// A utility to shift a new data value into a data array
//
static void shiftData(double *data, int len, double newValue)
{
    memmove(data, data + 1, sizeof(*data) * (len - 1));
    data[len - 1] = newValue;
}

//
// Shift new data values into the real time data series
//
void RealtimeTrack::getData()
{
    // The current time
    QDateTime now = QDateTime::currentDateTime();

    // This is our formula for the random number generator
    do
    {
        // We need the currentTime in millisecond resolution
        double currentTime = Chart::chartTime2(m_nextDataTime.toTime_t())
                             + m_nextDataTime.time().msec() / 1000.0;

        // Get a data sample
        double p = currentTime * 4;
        double dataA = 20 + cos(p * 129241) * 10 + 1 / (cos(p) * cos(p) + 0.01);
        double dataB = 150 + 100 * sin(p / 27.7) * sin(p / 10.1);
        double dataC = 150 + 100 * cos(p / 6.7) * cos(p / 11.9);

        // After obtaining the new values, we need to update the data arrays.
        if (m_currentIndex &lt; sampleSize)
        {
            // Store the new values in the current index position, and increment the index.
            m_dataSeriesA[m_currentIndex] = dataA;
            m_dataSeriesB[m_currentIndex] = dataB;
            m_dataSeriesC[m_currentIndex] = dataC;
            m_timeStamps[m_currentIndex] = currentTime;
            ++m_currentIndex;
        }
        else
        {
            // The data arrays are full. Shift the arrays and store the values at the end.
            shiftData(m_dataSeriesA, sampleSize, dataA);
            shiftData(m_dataSeriesB, sampleSize, dataB);
            shiftData(m_dataSeriesC, sampleSize, dataC);
            shiftData(m_timeStamps, sampleSize, currentTime);
        }

        m_nextDataTime = m_nextDataTime.addMSecs(DataInterval);
    }
    while (m_nextDataTime &lt; now);

    //
    // We provide some visual feedback to the latest numbers generated, so you can see the
    // data being generated.
    //
    m_ValueA-&gt;setText(QString::number(m_dataSeriesA[m_currentIndex - 1], 'f', 2));
    m_ValueB-&gt;setText(QString::number(m_dataSeriesB[m_currentIndex - 1], 'f', 2));
    m_ValueC-&gt;setText(QString::number(m_dataSeriesC[m_currentIndex - 1], 'f', 2));
}

//
// The Run or Freeze button is pressed
//
void RealtimeTrack::onRunFreezeChanged(int run)
{
    if (run)
        m_ChartUpdateTimer-&gt;start();
    else
        m_ChartUpdateTimer-&gt;stop();
}

//
// User changes the chart update period
//
void RealtimeTrack::onUpdatePeriodChanged(QString text)
{
    m_ChartUpdateTimer-&gt;start(text.toInt());
}

//
// Update the chart. Instead of drawing the chart directly, we call updateViewPort, which
// will trigger a ViewPortChanged signal. We update the chart in the signal handler
// "drawChart". This can take advantage of the built-in rate control in QChartViewer to
// ensure a smooth user interface, even for extremely high update rate. (See the
// documentation on QChartViewer.setUpdateInterval).
//
void RealtimeTrack::updateChart()
{
    m_ChartViewer-&gt;updateViewPort(true, false);
}

//
// Draw chart
//
void RealtimeTrack::drawChart()
{
    // Create an XYChart object 600 x 270 pixels in size, with light grey (f4f4f4) 
    // background, black (000000) border, 1 pixel raised effect, and with a rounded frame.
    XYChart *c = new XYChart(600, 270, 0xf4f4f4, 0x000000, 1);
    QColor bgColor = palette().color(backgroundRole()).rgb();
    c-&gt;setRoundedFrame((bgColor.red() &lt;&lt; 16) + (bgColor.green() &lt;&lt; 8) + bgColor.blue());

    // Set the plotarea at (55, 55) and of size 520 x 185 pixels. Use white (ffffff) 
    // background. Enable both horizontal and vertical grids by setting their colors to 
    // grey (cccccc). Set clipping mode to clip the data lines to the plot area.
    c-&gt;setPlotArea(55, 55, 520, 185, 0xffffff, -1, -1, 0xcccccc, 0xcccccc);
    c-&gt;setClipping();

    // Add a title to the chart using 15 pts Times New Roman Bold Italic font, with a light
    // grey (dddddd) background, black (000000) border, and a glass like raised effect.
    c-&gt;addTitle("Field Intensity at Observation Satellite", "timesbi.ttf", 15
        )-&gt;setBackground(0xdddddd, 0x000000, Chart::glassEffect());
            
    // Set the reference font size of the legend box
    c-&gt;getLegend()-&gt;setFontSize(8);

    // Configure the y-axis with a 10pts Arial Bold axis title
    c-&gt;yAxis()-&gt;setTitle("Intensity (V/m)", "arialbd.ttf", 10);

    // Configure the x-axis to auto-scale with at least 75 pixels between major tick and 
    // 15  pixels between minor ticks. This shows more minor grid lines on the chart.
    c-&gt;xAxis()-&gt;setTickDensity(75, 15);

    // Set the axes width to 2 pixels
    c-&gt;xAxis()-&gt;setWidth(2);
    c-&gt;yAxis()-&gt;setWidth(2);

    // Now we add the data to the chart. 
    double firstTime  = m_timeStamps[0];
    if (firstTime != Chart::NoValue)
    {
        // Set up the x-axis to show the time range in the data buffer
        c-&gt;xAxis()-&gt;setDateScale(firstTime, firstTime + DataInterval * sampleSize / 1000);
        
        // Set the x-axis label format
        c-&gt;xAxis()-&gt;setLabelFormat("{value|hh:nn:ss}");

        // Create a line layer to plot the lines
        LineLayer *layer = c-&gt;addLineLayer();

        // The x-coordinates are the timeStamps.
        layer-&gt;setXData(DoubleArray(m_timeStamps, sampleSize));

        // The 3 data series are used to draw 3 lines.
        layer-&gt;addDataSet(DoubleArray(m_dataSeriesA, sampleSize), 0xff0000, "Alpha");
        layer-&gt;addDataSet(DoubleArray(m_dataSeriesB, sampleSize), 0x00cc00, "Beta");
        layer-&gt;addDataSet(DoubleArray(m_dataSeriesC, sampleSize), 0x0000ff, "Gamma");
    }

    // Include track line with legend. If the mouse is on the plot area, show the track 
    // line with legend at the mouse position; otherwise, show them for the latest data
    // values (that is, at the rightmost position).
    trackLineLegend(c, m_ChartViewer-&gt;isMouseOnPlotArea() ? m_ChartViewer-&gt;getPlotAreaMouseX() :
        c-&gt;getPlotArea()-&gt;getRightX());

    // Set the chart image to the WinChartViewer
    delete m_ChartViewer-&gt;getChart();
    m_ChartViewer-&gt;setChart(c);
}

//
// Draw track cursor when mouse is moving over plotarea
//
void RealtimeTrack::onMouseMovePlotArea(QMouseEvent *)
{
    trackLineLegend((XYChart *)m_ChartViewer-&gt;getChart(), m_ChartViewer-&gt;getPlotAreaMouseX());
    m_ChartViewer-&gt;updateDisplay();
}

//
// Draw the track line with legend
//
void RealtimeTrack::trackLineLegend(XYChart *c, int mouseX)
{
    // Clear the current dynamic layer and get the DrawArea object to draw on it.
    DrawArea *d = c-&gt;initDynamicLayer();

    // The plot area object
    PlotArea *plotArea = c-&gt;getPlotArea();

    // Get the data x-value that is nearest to the mouse, and find its pixel coordinate.
    double xValue = c-&gt;getNearestXValue(mouseX);
    int xCoor = c-&gt;getXCoor(xValue);

    // Draw a vertical track line at the x-position
    d-&gt;vline(plotArea-&gt;getTopY(), plotArea-&gt;getBottomY(), xCoor, d-&gt;dashLineColor(0x000000, 0x0101));

    // Container to hold the legend entries
    vector&lt;string&gt; legendEntries;

    // Iterate through all layers to build the legend array
    for (int i = 0; i &lt; c-&gt;getLayerCount(); ++i) {
        Layer *layer = c-&gt;getLayerByZ(i);

        // The data array index of the x-value
        int xIndex = layer-&gt;getXIndexOf(xValue);

        // Iterate through all the data sets in the layer
        for (int j = 0; j &lt; layer-&gt;getDataSetCount(); ++j) {
            DataSet *dataSet = layer-&gt;getDataSetByZ(j);

            // We are only interested in visible data sets with names
            const char *dataName = dataSet-&gt;getDataName();
            int color = dataSet-&gt;getDataColor();
            if (dataName &amp;&amp; *dataName &amp;&amp; (color != (int)Chart::Transparent)) {
                // Build the legend entry, consist of the legend icon, name and data value.
                double dataValue = dataSet-&gt;getValue(xIndex);
                ostringstream legendEntry;
                legendEntry &lt;&lt; "&lt;*block*&gt;" &lt;&lt; dataSet-&gt;getLegendIcon() &lt;&lt; " " &lt;&lt; dataName &lt;&lt; ": " &lt;&lt;
                    ((dataValue == Chart::NoValue) ? "N/A" : c-&gt;formatValue(dataValue, "{value|P4}"))
                    &lt;&lt; "&lt;*/*&gt;";
                legendEntries.push_back(legendEntry.str());

                // Draw a track dot for data points within the plot area
                int yCoor = c-&gt;getYCoor(dataSet-&gt;getPosition(xIndex), dataSet-&gt;getUseYAxis());
                if ((yCoor &gt;= plotArea-&gt;getTopY()) &amp;&amp; (yCoor &lt;= plotArea-&gt;getBottomY())) {
                    d-&gt;circle(xCoor, yCoor, 4, 4, color, color);
                }
            }
        }
    }

    // Create the legend by joining the legend entries
    ostringstream legendText;
    legendText &lt;&lt; "&lt;*block,maxWidth=" &lt;&lt; plotArea-&gt;getWidth() &lt;&lt; "*&gt;&lt;*block*&gt;&lt;*font=arialbd.ttf*&gt;["
        &lt;&lt; c-&gt;xAxis()-&gt;getFormattedLabel(xValue, "hh:nn:ss") &lt;&lt; "]&lt;*/*&gt;";
    for (int i = ((int)legendEntries.size()) - 1; i &gt;= 0; --i)
        legendText &lt;&lt; "        " &lt;&lt; legendEntries[i];
    
    // Display the legend on the top of the plot area
    TTFText *t = d-&gt;text(legendText.str().c_str(), "arial.ttf", 8);
    t-&gt;draw(plotArea-&gt;getLeftX() + 5, plotArea-&gt;getTopY() - 3, 0x000000, Chart::BottomLeft);
    t-&gt;destroy();
}</pre></td></tr></table></div><br>
<hr class="separator"><div class="copyright">&copy; 2015 Advanced Software Engineering Limited. All rights reserved.</div></body>
</HTML>
